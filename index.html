<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Cyber City - Battle Royale</title>
    <style>
        /* ×ª×™×§×•×Ÿ ×œ××¡×š ×œ×‘×Ÿ ×‘×¨×¢× ×•×Ÿ - ×§×•×‘×¢ ×¨×§×¢ ×©×—×•×¨ ×œ×›×œ ×”×“×£ */
        html, body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #050510; 
            font-family: 'Segoe UI', sans-serif; 
            user-select: none;
            height: 100%;
        }
        
        /* ×××©×§ ××©×ª××© ×‘××©×—×§ */
        #game-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background: transparent;
            border: 2px solid rgba(0, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        #crosshair.hit {
            border-color: red;
            background: rgba(255, 0, 0, 0.4);
            transform: translate(-50%, -50%) scale(1.2);
            transition: 0.1s;
        }

        .hud-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 5px;
            color: white;
            border: 1px solid #00ffff;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            font-weight: bold;
        }

        #health-bar-container { bottom: 30px; left: 30px; width: 200px; height: 20px; background: #333; border: 1px solid #fff; }
        #health-bar { width: 100%; height: 100%; background: #ff0055; transition: width 0.2s; }
        #health-text { position: absolute; top: -25px; left: 0; color: #ff0055; font-size: 20px; }

        #ammo-display { bottom: 30px; right: 30px; font-size: 30px; color: #ffff00; }
        
        #alive-counter { 
            top: 20px; 
            right: 20px; 
            font-size: 24px; 
            color: #00ff00;
            background: rgba(0,0,0,0.8);
            border: 1px solid #00ff00;
            padding: 10px 20px;
        }
        
        #room-info {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 20px;
            color: cyan;
            text-align: center;
            text-shadow: 0 0 10px cyan;
        }

        /* ×ª×¤×¨×™×˜ ×¨××©×™ */
        .screen-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('https://images.unsplash.com/photo-1535868463750-c78d9543614f?q=80&w=1920&auto=format&fit=crop') no-repeat center center/cover;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
        }
        .screen-overlay::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            z-index: -1;
        }

        .menu-box {
            position: relative;
            background: rgba(10, 10, 30, 0.95);
            padding: 50px;
            border-radius: 15px;
            border: 2px solid #00ffff;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
            text-align: center;
            width: 400px;
        }

        h1 {
            font-size: 3.5rem;
            margin: 0 0 30px 0;
            color: #00ffff;
            text-transform: uppercase;
            text-shadow: 0 0 20px #00ffff;
            font-style: italic;
        }

        input {
            width: 100%;
            padding: 15px;
            font-size: 18px;
            background: #222;
            border: 1px solid #555;
            color: white;
            margin-bottom: 20px;
            text-align: center;
            box-sizing: border-box;
        }

        button {
            width: 100%;
            padding: 18px;
            font-size: 22px;
            margin-bottom: 15px;
            cursor: pointer;
            font-weight: bold;
            border: none;
            transition: 0.2s;
            text-transform: uppercase;
            border-radius: 5px;
        }

        .btn-single { background: #ff0055; color: white; box-shadow: 0 0 20px rgba(255, 0, 85, 0.4); }
        .btn-single:hover { background: #ff3377; transform: scale(1.02); }

        .btn-multi { background: transparent; border: 2px solid #00ffff; color: #00ffff; }
        .btn-multi:hover { background: rgba(0, 255, 255, 0.1); }
        
        .btn-create { background: linear-gradient(90deg, #00ffff, #0088ff); color: black; box-shadow: 0 0 15px rgba(0,255,255,0.3); }
        .btn-create:hover { transform: scale(1.02); }

        /* ××¡×š ×œ×•×‘×™ (×”××ª× ×”) */
        #lobby-waiting-screen { display: none; }
        .player-list {
            text-align: right;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            margin-bottom: 20px;
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #555;
        }
        .player-item { padding: 5px; border-bottom: 1px solid #333; color: #0f0; }

        /* ××¡×š ×¡×™×•× ××©×—×§ */
        #game-over-screen {
            display: none;
            z-index: 200;
        }
        #game-over-title { font-size: 60px; margin-bottom: 20px; }
        .win-text { color: #00ff00; text-shadow: 0 0 30px #00ff00; }
        .lose-text { color: #ff0000; text-shadow: 0 0 30px #ff0000; }
        
        #return-btn {
            background: #ffffff;
            color: #000;
            font-size: 24px;
            padding: 15px 40px;
            margin-top: 30px;
            transition: all 0.3s;
        }
        #return-btn:hover { background: #ddd; }
        #return-btn:disabled { background: #555; color: #888; cursor: wait; }

    </style>
    
    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <!-- ×ª×¤×¨×™×˜ ×¨××©×™ -->
    <div id="main-menu" class="screen-overlay">
        <div class="menu-box">
            <h1>CYBER CITY</h1>
            <input type="text" id="player-name" placeholder="×©× ×©×—×§×Ÿ" maxlength="10">
            
            <button class="btn-single" onclick="startSinglePlayer()">ğŸ‘‘ ×©×—×§ × ×’×“ ×‘×•×˜×™× (×™×—×™×“)</button>
            <div style="display: flex; gap: 10px;">
                <button class="btn-create" onclick="createLobby()">â• ×¦×•×¨ ×œ×•×‘×™</button>
                <button class="btn-multi" onclick="showMultiplayerInput()">ğŸŒ ×›× ×¡ ×œ×œ×•×‘×™</button>
            </div>
            
            <div id="multi-input-area" style="display:none; margin-top:15px; border-top:1px solid #444; padding-top:15px;">
                <input type="text" id="room-code" placeholder="×§×•×“ ×—×“×¨ (×œ××©×œ 1234)">
                <button class="btn-multi" style="font-size:16px; padding:10px;" onclick="joinMultiplayer()">×”×¦×˜×¨×£ ×œ×—×“×¨</button>
            </div>
            
            <div id="status-msg" style="color:yellow; margin-top:10px;"></div>
        </div>
    </div>

    <!-- ××¡×š ×”××ª× ×” (×œ×•×‘×™) -->
    <div id="lobby-waiting-screen" class="screen-overlay">
        <div class="menu-box">
            <h2>×—×“×¨ ×”××ª× ×”: <span id="lobby-code-display" style="color: #00ffff"></span></h2>
            <div class="player-list" id="lobby-player-list">
                <!-- ×¨×©×™××ª ×©×—×§× ×™× ×ª×•×¤×™×¢ ×›××Ÿ -->
            </div>
            <div id="host-controls" style="display: none;">
                <button class="btn-create" onclick="startGameAsHost()">ğŸš€ ×”×ª×—×œ ××©×—×§</button>
            </div>
            <div id="guest-controls">
                <p style="color: #aaa;">×××ª×™×Ÿ ×œ×××¨×— ×©×™×ª×—×™×œ ××ª ×”××©×—×§...</p>
            </div>
        </div>
    </div>

    <!-- ××¡×š ×¡×™×•× (× ×™×¦×—×•×Ÿ/×”×¤×¡×“) -->
    <div id="game-over-screen" class="screen-overlay">
        <div class="menu-box">
            <h1 id="game-over-title">GAME OVER</h1>
            <p id="game-over-desc" style="font-size: 24px; color: white;">×”×’×¢×ª ×œ××§×•× #5</p>
            <button id="return-btn" onclick="returnToMenu()">×—×–×•×¨ ×œ×ª×¤×¨×™×˜ ×”×¨××©×™</button>
        </div>
    </div>

    <!-- ×”××©×—×§ -->
    <div id="game-ui">
        <div id="crosshair"></div>
        <div id="room-info" class="hud-panel" style="display: none;">×—×“×¨: <span id="current-room-id"></span></div>
        
        <div id="health-bar-container">
            <div id="health-text">100</div>
            <div id="health-bar"></div>
        </div>
        
        <div id="ammo-display">âš¡ 20</div>
        <div id="alive-counter" class="hud-panel">× ×©××¨×• ×‘×—×™×™×: <span id="player-count">1</span></div>
    </div>

    <script>
        // --- ××©×ª× ×™× ×’×œ×•×‘×œ×™×™× ---
        const MAX_PLAYERS = 10;
        let db, auth;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app';
        
        // ××©×—×§
        let isSinglePlayer = true;
        let isGameRunning = false;
        let myId = null;
        let myUsername = "Player";
        let currentRoomCode = "";
        let isHost = false;
        let networkInterval = null;
        
        // Three.js
        let scene, camera, renderer;
        let players = {}; 
        let collidableObjects = []; 
        let buildingMeshes = []; 
        let floorPlane = null;
        
        // ×‘×˜×™×—×•×ª ×ª× ×•×¢×” (Anti-Stuck)
        let lastSafePos = new THREE.Vector3();

        // ×¤×™×–×™×§×”
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let moveForward=false, moveBackward=false, moveLeft=false, moveRight=false, canJump=false;
        let prevTime = performance.now();
        
        // ××¦×‘ ×©×—×§×Ÿ
        let hp = 100;
        let ammo = 20;
        let isReloading = false;
        let isDead = false;
        let aliveCount = 1;
        
        // ×‘×•×˜×™× (×¨×§ ×œ××¦×‘ ×™×—×™×“)
        let localBots = [];

        // ×‘×§×¨×ª ×¢×›×‘×¨
        const controls = { isLocked: false, getObject: () => camera };

        // --- ××ª×—×•×œ ---
        function initApp() {
            if (typeof __firebase_config !== 'undefined') {
                firebase.initializeApp(JSON.parse(__firebase_config));
                db = firebase.firestore();
                auth = firebase.auth();
            }
            
            // ×˜×¢×™× ×ª ×©× ×©××•×¨
            const savedName = localStorage.getItem('cyber_shooter_username');
            if (savedName) {
                document.getElementById('player-name').value = savedName;
                myUsername = savedName;
            }
        }

        // --- × ×™×”×•×œ ××¡×›×™× ---
        function showMultiplayerInput() {
            document.getElementById('multi-input-area').style.display = 'block';
        }

        async function createLobby() {
            const name = document.getElementById('player-name').value.trim();
            if (!name) {
                document.getElementById('status-msg').innerText = "×× × ×”×›× ×¡ ×©× ×©×—×§×Ÿ ×§×•×“×";
                return;
            }
            saveUsername(name);
            
            const newCode = Math.floor(1000 + Math.random() * 9000).toString();
            currentRoomCode = newCode;
            isHost = true;

            await connectToFirebase();
            
            // ×™×¦×™×¨×ª ×—×“×¨
            const roomDoc = db.collection('artifacts').doc(appId).collection('public').doc('data').collection('rooms').doc(newCode);
            await roomDoc.set({
                hostId: myId,
                status: 'waiting', 
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            });

            enterLobbyUI();
        }

        async function joinMultiplayer() {
            const name = document.getElementById('player-name').value.trim();
            const code = document.getElementById('room-code').value.trim();
            
            if(!name) { document.getElementById('status-msg').innerText = "×—×•×‘×” ×œ×”×–×™×Ÿ ×©×"; return; }
            if(!code) { document.getElementById('status-msg').innerText = "×—×•×‘×” ×œ×”×–×™×Ÿ ×§×•×“ ×—×“×¨"; return; }
            
            saveUsername(name);
            currentRoomCode = code;
            isHost = false;

            await connectToFirebase();
            
            const roomDoc = db.collection('artifacts').doc(appId).collection('public').doc('data').collection('rooms').doc(code);
            const docSnap = await roomDoc.get();
            
            if (!docSnap.exists) {
                document.getElementById('status-msg').innerText = "×”×—×“×¨ ×œ× × ××¦×";
                return;
            }
            
            enterLobbyUI();
        }

        async function connectToFirebase() {
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                await auth.signInWithCustomToken(__initial_auth_token);
            } else {
                await auth.signInAnonymously();
            }
            myId = auth.currentUser.uid;
        }

        function enterLobbyUI() {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('lobby-waiting-screen').style.display = 'flex';
            document.getElementById('lobby-code-display').innerText = currentRoomCode;

            if (isHost) {
                document.getElementById('host-controls').style.display = 'block';
                document.getElementById('guest-controls').style.display = 'none';
            } else {
                document.getElementById('host-controls').style.display = 'none';
                document.getElementById('guest-controls').style.display = 'block';
            }

            // ×¨×™×©×•×
            const roomDoc = db.collection('artifacts').doc(appId).collection('public').doc('data').collection('rooms').doc(currentRoomCode);
            roomDoc.collection('players').doc(myId).set({
                username: myUsername,
                isReady: true,
                hp: 100,
                isDead: false
            });

            listenToLobby();
        }

        function listenToLobby() {
            const roomDoc = db.collection('artifacts').doc(appId).collection('public').doc('data').collection('rooms').doc(currentRoomCode);

            // ×¨×©×™××ª ×©×—×§× ×™×
            roomDoc.collection('players').onSnapshot(snapshot => {
                const listEl = document.getElementById('lobby-player-list');
                listEl.innerHTML = '';
                let count = 0;
                snapshot.forEach(doc => {
                    const data = doc.data();
                    const item = document.createElement('div');
                    item.className = 'player-item';
                    item.innerText = "ğŸ‘¤ " + data.username;
                    listEl.appendChild(item);
                    count++;
                });
                aliveCount = count; // ×¢×“×›×•×Ÿ ××¡×¤×¨ ×©×—×§× ×™× ×œ×—×™×©×•×‘ × ×›×•×Ÿ ×‘××©×—×§
            });

            // ×¡×˜×˜×•×¡ ×—×“×¨
            roomDoc.onSnapshot(doc => {
                if (doc.exists) {
                    const data = doc.data();
                    if (data.status === 'playing' && !isGameRunning) {
                        startMultiplayerGame();
                    }
                }
            });
        }

        function startGameAsHost() {
            if (!isHost) return;
            const roomDoc = db.collection('artifacts').doc(appId).collection('public').doc('data').collection('rooms').doc(currentRoomCode);
            roomDoc.update({ status: 'playing' });
        }

        // --- ×”×ª×—×œ×ª ××©×—×§ ××•×œ×˜×™×¤×œ×™×™×¨ (×œ×œ× ×‘×•×˜×™×!) ---
        function startMultiplayerGame() {
            isSinglePlayer = false;
            document.getElementById('lobby-waiting-screen').style.display = 'none';
            document.getElementById('game-ui').style.display = 'block';
            document.getElementById('room-info').style.display = 'block';
            document.getElementById('current-room-id').innerText = currentRoomCode;

            initGameWorld();
            setupNetworkGame(); // ×”×’×“×¨×ª ×¡× ×›×¨×•×Ÿ ×¨×©×ª
            
            isGameRunning = true;
            animate();
            setTimeout(() => document.body.requestPointerLock(), 100);
        }

        function setupNetworkGame() {
            // 1. ×©×œ×™×—×ª × ×ª×•× ×™× ×©×œ×™ ×œ×©×¨×ª
            networkInterval = setInterval(() => {
                if(!isDead && isGameRunning) {
                    const roomDoc = db.collection('artifacts').doc(appId).collection('public').doc('data').collection('rooms').doc(currentRoomCode);
                    roomDoc.collection('players').doc(myId).update({
                        x: camera.position.x,
                        y: camera.position.y,
                        z: camera.position.z,
                        rotY: camera.rotation.y,
                        hp: hp,
                        isDead: isDead
                    });
                }
            }, 80); // ×©×œ×™×—×” ×›×œ 80ms

            // 2. ×”××–× ×” ×œ×©×—×§× ×™× ××—×¨×™×
            const roomDoc = db.collection('artifacts').doc(appId).collection('public').doc('data').collection('rooms').doc(currentRoomCode);
            roomDoc.collection('players').onSnapshot(snapshot => {
                // ×—×™×©×•×‘ ×©×—×§× ×™× ×—×™×™×
                let livePlayers = 0;
                
                snapshot.docChanges().forEach(change => {
                    const pid = change.doc.id;
                    const data = change.doc.data();
                    if(pid === myId) {
                        // ×× ×¢×“×›× ×• ×œ×™ ×—×™×™× (××™×©×”×• ×™×¨×” ×‘×™)
                        if(data.hp < hp) takeDamage(hp - data.hp);
                        return;
                    }

                    if (change.type === "added" || change.type === "modified") {
                        if (!players[pid]) {
                            // ×™×¦×™×¨×ª ×©×—×§×Ÿ ×—×“×© (×™×¨×•×§ ×›×™ ×”×•× ×©×—×§×Ÿ ×××™×ª×™)
                            const mesh = createPlayerMesh(false, data.username); 
                            scene.add(mesh);
                            players[pid] = { mesh: mesh, id: pid };
                        }
                        // ×¢×“×›×•×Ÿ ××™×§×•×
                        const p = players[pid];
                        if(data.isDead) {
                            p.mesh.visible = false;
                        } else {
                            p.mesh.visible = true;
                            p.mesh.position.set(data.x || 0, data.y || 1.7, data.z || 0);
                            p.mesh.rotation.y = data.rotY || 0;
                        }
                    }
                    if (change.type === "removed") {
                        if(players[pid]) {
                            scene.remove(players[pid].mesh);
                            delete players[pid];
                        }
                    }
                });

                // ×¡×¤×™×¨×ª ×—×™×™×
                snapshot.forEach(doc => {
                    if(!doc.data().isDead) livePlayers++;
                });
                aliveCount = livePlayers;
                updatePlayerCount();
                
                // ×‘×“×™×§×ª × ×™×¦×—×•×Ÿ (×× × ×©××¨×ª×™ ×œ×‘×“)
                if(aliveCount === 1 && !isDead && snapshot.size > 1) {
                    setTimeout(() => endGame(true), 1000);
                }
            });
        }

        function returnToMenu() {
            const btn = document.getElementById('return-btn');
            btn.innerText = "×—×•×–×¨ ×œ×ª×¤×¨×™×˜...";
            btn.disabled = true;
            saveUsername(myUsername);
            setTimeout(() => { location.reload(); }, 2000);
        }

        function endGame(won, rank) {
            isGameRunning = false;
            if(networkInterval) clearInterval(networkInterval);
            document.exitPointerLock();
            document.getElementById('game-ui').style.display = 'none';
            document.getElementById('game-over-screen').style.display = 'flex';
            
            const title = document.getElementById('game-over-title');
            const desc = document.getElementById('game-over-desc');
            const btn = document.getElementById('return-btn');
            
            btn.innerText = "×—×–×•×¨ ×œ×ª×¤×¨×™×˜ ×”×¨××©×™";
            btn.disabled = false;

            if (won) {
                title.innerText = "ğŸ† × ×™×¦×—×•×Ÿ!";
                title.className = 'win-text';
                desc.innerText = "×”×™×™×ª ×”×©×•×¨×“ ×”××—×¨×•×Ÿ!";
            } else {
                title.innerText = "ğŸ’€ ×”×¤×¡×“×ª";
                title.className = 'lose-text';
                desc.innerText = "×”×•×“×—×ª ××”××©×—×§.";
            }
        }

        function saveUsername(name) {
            if(name) {
                localStorage.setItem('cyber_shooter_username', name);
                myUsername = name;
            }
        }

        async function startSinglePlayer() {
            const name = document.getElementById('player-name').value.trim() || "Hero";
            saveUsername(name);
            isSinglePlayer = true;
            myId = "local_player";

            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('game-ui').style.display = 'block';

            aliveCount = MAX_PLAYERS;
            updatePlayerCount();

            initGameWorld();
            
            // ×™×¦×™×¨×ª ×‘×•×˜×™× (×¨×§ ×‘×™×—×™×“)
            for(let i=1; i<MAX_PLAYERS; i++) {
                spawnBot(i);
            }

            isGameRunning = true;
            animate();
            setTimeout(() => document.body.requestPointerLock(), 100);
        }

        // --- ×‘× ×™×™×ª ×”×¢×•×œ× ---
        function initGameWorld() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020205);
            scene.fog = new THREE.Fog(0x020205, 10, 200); 

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            const ambient = new THREE.AmbientLight(0x404040, 1.5);
            scene.add(ambient);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            scene.add(dirLight);

            createCity();
            
            const spawn = getSafeSpawnPos();
            camera.position.set(spawn.x, 1.7, spawn.z);
            lastSafePos.copy(camera.position); 
            
            setupControls();
        }

        function createCity() {
            const floorGeo = new THREE.PlaneGeometry(600, 600);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.9 });
            floorPlane = new THREE.Mesh(floorGeo, floorMat);
            floorPlane.rotation.x = -Math.PI / 2;
            floorPlane.receiveShadow = true;
            scene.add(floorPlane);

            const grid = new THREE.GridHelper(600, 60, 0x333333, 0x111111);
            scene.add(grid);

            const buildingMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.2 });
            const neonMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            const neonRedMat = new THREE.MeshBasicMaterial({ color: 0xff0055 });

            for(let i=0; i<200; i++) {
                const width = 5 + Math.random() * 15;
                const depth = 5 + Math.random() * 15;
                const height = 10 + Math.random() * 30;
                
                const x = (Math.random() - 0.5) * 500;
                const z = (Math.random() - 0.5) * 500;

                if(Math.abs(x) < 20 && Math.abs(z) < 20) continue;

                const geo = new THREE.BoxGeometry(width, height, depth);
                const mesh = new THREE.Mesh(geo, buildingMat);
                mesh.position.set(x, height/2, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                
                const edges = new THREE.EdgesGeometry(geo);
                const color = Math.random() > 0.5 ? neonMat : neonRedMat;
                const line = new THREE.LineSegments(edges, color);
                mesh.add(line);

                scene.add(mesh);
                buildingMeshes.push(mesh);
                
                mesh.geometry.computeBoundingBox();
                const box = new THREE.Box3().setFromObject(mesh);
                collidableObjects.push(box);
            }
            
            const bounds = 295;
            const wallThick = 20;
            collidableObjects.push(new THREE.Box3(new THREE.Vector3(-bounds, 0, -bounds-wallThick), new THREE.Vector3(bounds, 50, -bounds)));
            collidableObjects.push(new THREE.Box3(new THREE.Vector3(-bounds, 0, bounds), new THREE.Vector3(bounds, 50, bounds+wallThick)));
            collidableObjects.push(new THREE.Box3(new THREE.Vector3(-bounds-wallThick, 0, -bounds), new THREE.Vector3(-bounds, 50, bounds)));
            collidableObjects.push(new THREE.Box3(new THREE.Vector3(bounds, 0, -bounds), new THREE.Vector3(bounds+wallThick, 50, bounds)));
        }

        // --- ×¤×™×–×™×§×” ---
        function checkCollision(position) {
            const playerRadius = 0.3;
            const playerBox = new THREE.Box3();
            playerBox.min.set(position.x - playerRadius, position.y - 1.5, position.z - playerRadius);
            playerBox.max.set(position.x + playerRadius, position.y + 0.5, position.z + playerRadius);

            for (let box of collidableObjects) {
                if (playerBox.intersectsBox(box)) {
                    return true;
                }
            }
            return false;
        }

        function checkLineOfSight(start, end) {
            const raycaster = new THREE.Raycaster();
            const dir = new THREE.Vector3().subVectors(end, start).normalize();
            const dist = start.distanceTo(end);
            
            raycaster.set(start, dir);
            const intersects = raycaster.intersectObjects(buildingMeshes, true);
            
            if (intersects.length > 0) {
                if (intersects[0].distance < dist) {
                    return false;
                }
            }
            return true;
        }

        // --- ×‘×•×˜×™× (×¨×§ ×œ×¡×™× ×’×œ) ---
        function spawnBot(index) {
            if(!isSinglePlayer) return; // ×”×’× ×” × ×•×¡×¤×ª
            const botId = `bot_${index}`;
            const pos = getSafeSpawnPos(); 

            const botMesh = createPlayerMesh(true, "Bot " + index);
            botMesh.position.copy(pos);
            scene.add(botMesh);

            localBots.push({
                id: botId,
                mesh: botMesh,
                hp: 100,
                targetPos: null,
                state: 'patrol',
                shootTimer: 0,
                strafeDir: 1,
                reactionTimer: 0
            });
        }

        function getClosestTarget(bot) {
            let closest = null;
            let minDst = 1000; 

            if (!isDead) {
                const dst = bot.mesh.position.distanceTo(camera.position);
                if (dst < minDst) {
                    closest = { pos: camera.position, type: 'player', obj: null };
                    minDst = dst;
                }
            }

            localBots.forEach(other => {
                if (other.id !== bot.id && other.hp > 0) {
                     const dst = bot.mesh.position.distanceTo(other.mesh.position);
                     if (dst < minDst) {
                         closest = { pos: other.mesh.position, type: 'bot', obj: other };
                         minDst = dst;
                     }
                }
            });

            return closest;
        }

        function updateBots(delta) {
            localBots.forEach(bot => {
                if(bot.hp <= 0) return;

                const botPos = bot.mesh.position.clone();
                const target = getClosestTarget(bot); 

                if (target) {
                    const distToTarget = botPos.distanceTo(target.pos);
                    const canSee = checkLineOfSight(botPos.clone().add(new THREE.Vector3(0,1.7,0)), target.pos);

                    if (canSee) {
                        bot.state = 'fight';
                        let moveDir = new THREE.Vector3();
                        
                        if (distToTarget > 20) {
                            moveDir.subVectors(target.pos, botPos).normalize();
                        } else {
                            bot.reactionTimer -= delta;
                            if(bot.reactionTimer <= 0) {
                                bot.strafeDir *= -1;
                                bot.reactionTimer = 1 + Math.random() * 2;
                            }
                            const forward = new THREE.Vector3().subVectors(target.pos, botPos).normalize();
                            const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();
                            moveDir = right.multiplyScalar(bot.strafeDir);
                        }

                        const speed = 6.0;
                        const nextPos = bot.mesh.position.clone().add(moveDir.multiplyScalar(speed * delta));
                        
                        if (!checkCollision(nextPos)) {
                            bot.mesh.position.x = nextPos.x;
                            bot.mesh.position.z = nextPos.z;
                        }
                        
                        bot.mesh.lookAt(target.pos.x, bot.mesh.position.y, target.pos.z);
                        
                        bot.shootTimer -= delta;
                        if(bot.shootTimer <= 0) {
                            bot.shootTimer = 0.8 + Math.random() * 1.5; 
                            const shootTarget = target.pos.clone();
                            shootTarget.x += (Math.random()-0.5) * 2;
                            shootTarget.y -= 0.5;

                            createLaser(bot.mesh.position, shootTarget, 0xff0000);
                            
                            if (Math.random() < 0.4) {
                                 if (target.type === 'player') {
                                     takeDamage(8);
                                 } else if (target.type === 'bot' && target.obj) {
                                     target.obj.hp -= 8;
                                     target.obj.mesh.children[0].material.emissive.setHex(0xff0000);
                                     setTimeout(() => { if(target.obj.mesh) target.obj.mesh.children[0].material.emissive.setHex(0x000000); }, 100);
                                     if (target.obj.hp <= 0) killBot(target.obj);
                                 }
                            }
                        }
                    } else {
                        bot.state = 'hunt';
                        const moveDir = new THREE.Vector3().subVectors(target.pos, botPos).normalize();
                        const speed = 5.0;
                        const nextPos = bot.mesh.position.clone().add(moveDir.multiplyScalar(speed * delta));
                        
                        if (!checkCollision(nextPos)) {
                            bot.mesh.position.x = nextPos.x;
                            bot.mesh.position.z = nextPos.z;
                            bot.mesh.lookAt(nextPos.x, bot.mesh.position.y, nextPos.z);
                        }
                    }

                } else {
                     if (!bot.targetPos || bot.mesh.position.distanceTo(bot.targetPos) < 5) {
                        const huntingBias = camera.position.clone();
                        huntingBias.x += (Math.random() - 0.5) * 60;
                        huntingBias.z += (Math.random() - 0.5) * 60;
                        bot.targetPos = huntingBias;
                    }
                    
                    const moveDir = new THREE.Vector3().subVectors(bot.targetPos, bot.mesh.position).normalize();
                    const nextPos = bot.mesh.position.clone().add(moveDir.multiplyScalar(4.0 * delta));
                    
                    if (!checkCollision(nextPos)) {
                        bot.mesh.position.x = nextPos.x;
                        bot.mesh.position.z = nextPos.z;
                        bot.mesh.lookAt(bot.targetPos.x, bot.mesh.position.y, bot.targetPos.z);
                    } else {
                        bot.targetPos = getRandomSpawnPos(); 
                    }
                }
                
                bot.mesh.position.y = 1.5;
            });
        }

        // --- ×©×œ×™×˜×” ---
        function setupControls() {
            const onKey = (e, down) => {
                switch(e.code) {
                    case 'KeyW': moveForward = down; break;
                    case 'KeyS': moveBackward = down; break;
                    case 'KeyA': moveLeft = down; break;
                    case 'KeyD': moveRight = down; break;
                    case 'Space': if(down && canJump) { velocity.y += 28; canJump = false; } break;
                    case 'KeyR': if(down) reload(); break;
                }
            };
            document.addEventListener('keydown', e => onKey(e, true));
            document.addEventListener('keyup', e => onKey(e, false));
            
            document.addEventListener('mousemove', e => {
                if(controls.isLocked && !isDead) {
                    camera.rotation.y -= e.movementX * 0.002;
                }
            });
            
            document.addEventListener('mousedown', () => {
                if(controls.isLocked && !isDead) shoot();
                else if(!isDead) document.body.requestPointerLock();
            });
            
            document.addEventListener('pointerlockchange', () => {
                controls.isLocked = (document.pointerLockElement === document.body);
            });
        }

        function shoot() {
            if(ammo <= 0 || isReloading) return;
            ammo--;
            updateHUD();
            if(ammo===0) reload();

            const endPoint = new THREE.Vector3(0, 0, -100).applyMatrix4(camera.matrixWorld);
            const startPoint = new THREE.Vector3(0.5, -0.5, -1).applyMatrix4(camera.matrixWorld);
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);

            // ××™×¡×•×£ ××˜×¨×•×ª ×‘×”×ª×× ×œ××¦×‘ ××©×—×§
            const targets = [];
            if(isSinglePlayer) {
                localBots.forEach(bot => { if(bot.hp > 0) targets.push(bot.mesh); });
            } else {
                // ×‘××•×œ×˜×™×¤×œ×™×™×¨ ×™×•×¨×™× ×‘×©×—×§× ×™×
                for(let pid in players) {
                    targets.push(players[pid].mesh);
                }
            }
            
            const allMeshesToCheck = [...targets, ...buildingMeshes];
            const intersects = raycaster.intersectObjects(allMeshesToCheck, true);
            let laserEnd = endPoint;

            if(intersects.length > 0) {
                const hitInfo = intersects[0];
                const hitObj = hitInfo.object;
                laserEnd = hitInfo.point;

                let isBuilding = true;
                let rootObj = hitObj;
                while(rootObj.parent && rootObj.parent.type !== 'Scene') rootObj = rootObj.parent;

                // ×‘×“×™×§×ª ×¤×’×™×¢×” ×‘×‘×•×˜ (×™×—×™×“)
                if(isSinglePlayer) {
                    const hitBot = localBots.find(b => b.mesh === rootObj);
                    if(hitBot) {
                        hitBot.hp -= 25;
                        flashHit(hitBot.mesh);
                        showHitMarker();
                        if(hitBot.hp <= 0) killBot(hitBot);
                        isBuilding = false;
                    }
                } 
                // ×‘×“×™×§×ª ×¤×’×™×¢×” ×‘×©×—×§×Ÿ (××•×œ×˜×™)
                else {
                    for(let pid in players) {
                        if(players[pid].mesh === rootObj) {
                            isBuilding = false;
                            // ×¤×’×™×¢×” ×‘×©×—×§×Ÿ ×‘×¨×©×ª!
                            showHitMarker();
                            damageNetworkPlayer(pid, 25);
                            break;
                        }
                    }
                }
            }
            createLaser(startPoint, laserEnd, 0x00ffff);
        }
        
        function damageNetworkPlayer(targetId, dmg) {
            // ×¢×“×›×•×Ÿ ×”-HP ×©×œ ×”×™×¨×™×‘ ×‘×“××˜×”×‘×™×™×¡ (×¢×¡×§×ª ×—×œ×™×¤×™×Ÿ)
            const playerRef = db.collection('artifacts').doc(appId).collection('public').doc('data').collection('rooms').doc(currentRoomCode).collection('players').doc(targetId);
            db.runTransaction((transaction) => {
                return transaction.get(playerRef).then((sfDoc) => {
                    if (!sfDoc.exists) return;
                    const newHp = Math.max(0, sfDoc.data().hp - dmg);
                    transaction.update(playerRef, { hp: newHp, isDead: newHp <= 0 });
                });
            });
        }

        function flashHit(mesh) {
            mesh.children[0].material.emissive.setHex(0xff0000);
            setTimeout(() => mesh.children[0].material.emissive.setHex(0x000000), 100);
        }
        
        function showHitMarker() {
            const ch = document.getElementById('crosshair');
            ch.classList.add('hit');
            setTimeout(()=>ch.classList.remove('hit'), 150);
        }

        function createLaser(start, end, color) {
            const geo = new THREE.BufferGeometry().setFromPoints([start, end]);
            const mat = new THREE.LineBasicMaterial({ color: color });
            const line = new THREE.Line(geo, mat);
            if(scene) scene.add(line);
            setTimeout(() => { if(scene) scene.remove(line); }, 80);
        }

        function reload() {
            isReloading = true;
            document.getElementById('ammo-display').style.opacity = 0.5;
            setTimeout(() => {
                ammo = 20;
                isReloading = false;
                updateHUD();
                document.getElementById('ammo-display').style.opacity = 1;
            }, 1500);
        }

        // --- ×¢×–×¨×™× ---
        function createPlayerMesh(isEnemy, nameText) {
            const group = new THREE.Group();
            const color = isEnemy ? 0xff0000 : 0x00ff00;
            
            const body = new THREE.Mesh(new THREE.BoxGeometry(1, 1.5, 0.6), new THREE.MeshLambertMaterial({color: color}));
            body.position.y = 0.75;
            group.add(body);
            
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshLambertMaterial({color: 0xffaaaa}));
            head.position.y = 1.75;
            group.add(head);

            if(nameText) {
                const label = createTextLabel(nameText);
                label.position.set(0, 2.5, 0);
                group.add(label);
            }

            return group;
        }

        function createTextLabel(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 300;
            canvas.height = 100;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = "rgba(0,0,0,0.5)"; 
            ctx.fillRect(0,0,300,100);
            ctx.font = "Bold 50px Arial";
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(text, 150, 50);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(4, 1.3, 1);
            return sprite;
        }

        function getRandomSpawnPos() {
            const range = 280;
            const x = (Math.random() - 0.5) * 2 * range;
            const z = (Math.random() - 0.5) * 2 * range;
            return new THREE.Vector3(x, 1, z);
        }

        function getSafeSpawnPos() {
            let pos = new THREE.Vector3();
            for(let i=0; i<50; i++) {
                pos = getRandomSpawnPos();
                if(!checkCollision(new THREE.Vector3(pos.x, 1.7, pos.z))) {
                    return pos;
                }
            }
            return new THREE.Vector3(0, 50, 0);
        }

        function updateHUD() {
            document.getElementById('health-text').innerText = hp;
            document.getElementById('health-bar').style.width = hp + '%';
            document.getElementById('ammo-display').innerText = `âš¡ ${ammo}`;
        }
        
        function updatePlayerCount() {
            document.getElementById('player-count').innerText = aliveCount;
        }

        // --- ×œ×•×œ××” ×¨××©×™×ª ---
        function animate() {
            requestAnimationFrame(animate);
            if(!isGameRunning) return;

            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            if(controls.isLocked && !isDead) {
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 40.0 * delta; 

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 600.0 * delta;
                if (moveLeft || moveRight) velocity.x += direction.x * 600.0 * delta; 

                const nextX = velocity.x * delta;
                const nextZ = velocity.z * delta;
                
                const oldPos = controls.getObject().position.clone();
                controls.getObject().translateX(nextX);
                if (checkCollision(controls.getObject().position)) {
                    controls.getObject().position.copy(oldPos); 
                    velocity.x = 0;
                }

                const oldPosZ = controls.getObject().position.clone();
                controls.getObject().translateZ(nextZ);
                if (checkCollision(controls.getObject().position)) {
                    controls.getObject().position.copy(oldPosZ); 
                    velocity.z = 0;
                }

                controls.getObject().position.y += (velocity.y * delta);
                if (controls.getObject().position.y < 1.7) {
                    velocity.y = 0;
                    controls.getObject().position.y = 1.7;
                    canJump = true;
                }

                if (checkCollision(controls.getObject().position)) {
                    controls.getObject().position.copy(lastSafePos);
                    velocity.set(0,0,0);
                } else {
                    lastSafePos.copy(controls.getObject().position);
                }
            }
            
            if(isSinglePlayer && localBots.length > 0) updateBots(delta);

            if(renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }
        
        window.addEventListener('resize', () => {
            if(camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });

        initApp();
        
    </script>
</body>
</html>
